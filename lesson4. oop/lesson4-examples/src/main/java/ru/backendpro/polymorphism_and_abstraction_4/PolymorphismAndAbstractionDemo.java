package ru.backendpro.polymorphism_and_abstraction_4;

/**
 Автор: Денис Кивилёв
 Online-школа: Backend-pro.ru

 Описание: ДЕМО-КОД ДЛЯ ЛЕКЦИИ 4: ООП — ЧАСТЬ 5.
 ПОЛИМОРФИЗМ И АБСТРАКЦИЯ

 Показываем на практике:
 
 БЛОК 1: Полиморфизм (Polymorphism)
 - "Много форм" — один интерфейс, разные реализации
 - Работа с объектами через общий тип
 - Runtime polymorphism через переопределение методов
 
 БЛОК 2: Абстрактные классы (Abstract Classes)
 - Класс, который нельзя инстанцировать
 - Абстрактные методы (без реализации)
 - Обычные методы (с реализацией)
 
 БЛОК 3: Практический пример
 - Платёжная система: Payment → CardPayment, BankTransferPayment
 - Полиморфная обработка разных типов платежей
 
 ВАЖНО:
 - полиморфизм = гибкость + расширяемость
 - один метод работает с разными типами
 - абстрактные классы и обычные - разные
 */
public class PolymorphismAndAbstractionDemo {

    public static void main(String[] args) {
        /* ========================================
         * БЛОК 1: ПОЛИМОРФИЗМ (POLYMORPHISM)
         * ========================================
         * Полиморфизм = "много форм" — один интерфейс, разные реализации
         * Работа с объектами через общий тип
         * Runtime polymorphism через переопределение методов
         */
        
        /* Создаём массив разных типов людей
         * Все объекты хранятся в массиве типа Person[], но каждый объект вызывает СВОЮ версию introduce()
         * Это и есть ПОЛИМОРФИЗМ (runtime polymorphism)
         */
        Person[] people = {
            new Person("Алексей"),
            new Client(1L, "Иван"),
            new Employee("Мария", "Разработчик"),
            new Manager("Пётр", 5)
        };
        
        /* Вызываем метод introduce() для каждого
         * ПОЛИМОРФИЗМ: один метод, разные реализации
         * Преимущества полиморфизма:
         * 1. Гибкость — один метод работает с разными типами
         * 2. Расширяемость — легко добавить новые типы
         * 3. Упрощение кода — не нужно писать отдельный код для каждого типа
         */
        for (Person person : people) {
            person.introduce(); // Вызывается метод конкретного типа!
        }

        /* ========================================
         * БЛОК 2: АБСТРАКТНЫЕ КЛАССЫ
         * ========================================
         * Абстрактный класс — это класс, который:
         * 1. НЕЛЬЗЯ инстанцировать (создать объект)
         * 2. Может содержать абстрактные методы (без реализации)
         * 3. Может содержать обычные методы (с реализацией)
         * 4. Подклассы ОБЯЗАНЫ реализовать все абстрактные методы
         */
        
        /* Попытка создать объект абстрактного класса вызовет ошибку:
         * Shape shape = new Shape("зелёный"); // ОШИБКА КОМПИЛЯЦИИ!
         */
        
        Shape circle = new Circle("красный", 5.0);
        Shape rectangle = new Rectangle("синий", 4.0, 6.0);
        
        circle.printInfo();
        rectangle.printInfo();
        
        /* Зачем нужны абстрактные классы:
         * 1. Определить общий интерфейс для группы классов
         * 2. Заставить подклассы реализовать определённые методы
         * 3. Предоставить общую реализацию для некоторых методов
         */

        /* ========================================
         * БЛОК 3: ПРАКТИЧЕСКИЙ ПРИМЕР (ПЛАТЁЖНАЯ СИСТЕМА)
         * ========================================
         * Платёжная система: Payment → CardPayment, BankTransferPayment, EWalletPayment
         * Полиморфная обработка разных типов платежей
         */
        
        Payment[] payments = {
            new CardPayment(1L, 1000.0, "1234567890123456"),
            new BankTransferPayment(2L, 2000.0, "40817810099910004312"),
            new EWalletPayment(3L, 500.0, "wallet@example.com")
        };

        PaymentProcessor processor = new PaymentProcessor();
        processor.processPayments(payments);

        double totalCommission = processor.calculateTotalCommission(payments);
        System.out.println("Общая комиссия: " + totalCommission + " руб.");
        
        /* Что мы видим:
         * 1. Один метод processPayments() работает с РАЗНЫМИ типами платежей
         * 2. Каждый тип платежа реализует process() и calculateCommission() ПО-СВОЕМУ
         * 3. Легко добавить новый тип платежа (например, CryptoPayment)
         * 4. Код PaymentProcessor НЕ нужно менять при добавлении новых типов
         */

        /* ========================================
         * ИТОГИ
         * ========================================
         * Ключевые выводы:
         * 1. ПОЛИМОРФИЗМ = один интерфейс, разные реализации
         * 2. Работа с объектами через общий тип (Person[], Payment[])
         * 3. Runtime polymorphism через переопределение методов (@Override)
         * 4. АБСТРАКТНЫЙ КЛАСС = шаблон для подклассов
         * 5. Абстрактные методы ОБЯЗАТЕЛЬНО реализуются в подклассах
         * 6. Обычные методы в абстрактном классе — общая логика
         * 7. Нельзя создать объект абстрактного класса
         */
    }
}
