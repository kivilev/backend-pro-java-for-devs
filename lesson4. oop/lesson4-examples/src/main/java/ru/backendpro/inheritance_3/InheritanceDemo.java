package ru.backendpro.inheritance_3;

/**
 Автор: Денис Кивилёв
 Online-школа: Backend-pro.ru

 Описание: ДЕМО-КОД ДЛЯ ЛЕКЦИИ 4: ООП — ЧАСТЬ 4. НАСЛЕДОВАНИЕ

 Показываем на практике:
 
 БЛОК 1: Концепция наследования (is-a)
 - Суперкласс Person → Подклассы Client, Employee
 - Переиспользование кода
 - Иерархия классов
 
 БЛОК 2: Ключевое слово super
 - Вызов конструктора суперкласса
 - Вызов метода суперкласса
 - Доступ к полям суперкласса
 
 БЛОК 3: Переопределение методов (@Override)
 - Изменение поведения метода в подклассе
 - Правила переопределения
 - Аннотация @Override
 
 БЛОК 4: final классы и методы
 - Запрет наследования (final class)
 - Запрет переопределения (final method)
 - Неизменяемые поля (final field)
 
 ВАЖНО ДЛЯ ПРЕПОДАВАТЕЛЯ:
 - Подчеркните отношение "is-a": Client IS-A Person
 - Покажите, что наследуется (public/protected), а что нет (private)
 - Объясните, почему super() должен быть первой строкой
 */
public class InheritanceDemo {

    public static void main(String[] args) {
        /* ========================================
         * БЛОК 1: КОНЦЕПЦИЯ НАСЛЕДОВАНИЯ (IS-A)
         * ========================================
         * Наследование = переиспользование кода через extends
         * Суперкласс Person → Подклассы Client, Employee
         * Иерархия классов
         */
        
        // СУПЕРКЛАСС (базовый класс, родительский класс)
        Person person = new Person("Алексей Смирнов", "alexey@example.com");
        Client client = new Client(1L, "Иван Петров", "ivan@example.com", "+79001234567");
        Employee employee = new Employee(100L, "Мария Иванова", "maria@example.com", "Менеджер", 80000.0);

        System.out.println(person.getInfo());
        System.out.println(client.getInfo());
        System.out.println(employee.getInfo());

        person.sendNotification("Добро пожаловать!");
        client.sendNotification("Ваш платёж обработан");
        client.makePayment(1000.0);
        employee.sendNotification("Новая задача");
        employee.processPayment(1000.0);
        
        /* ОТНОШЕНИЕ IS-A:
         * - Client IS-A Person ✓
         * - Employee IS-A Person ✓
         * - Client наследует поля name, email и метод sendNotification()
         * - Employee наследует поля name, email и метод sendNotification()
         */
        
        /* ЧТО НАСЛЕДУЕТСЯ:
         * ✓ public и protected поля и методы
         * ✗ private поля и методы (но они есть в объекте!)
         * ✗ Конструкторы
         */

        /* ========================================
         * БЛОК 2: КЛЮЧЕВОЕ СЛОВО SUPER
         * ========================================
         * super используется для:
         * - Вызова конструктора суперкласса
         * - Вызова метода суперкласса
         * - Доступа к полям суперкласса
         */
        
        // Создаём кота (смотрите порядок вызова конструкторов в консоли)
        Cat cat = new Cat("Барсик");
        
        // Вызываем переопределённый метод
        cat.makeSound();
        
        // Выводим информацию
        cat.printInfo();
        
        /* ВАЖНО:
         * 1. super() должен быть ПЕРВОЙ строкой в конструкторе
         * 2. Если не указать super(), Java автоматически вызовет super()
         * 3. super.method() вызывает метод суперкласса
         * 4. super.field обращается к полю суперкласса
         */

        /* ========================================
         * БЛОК 3: ПЕРЕОПРЕДЕЛЕНИЕ МЕТОДОВ (@Override)
         * ========================================
         * Переопределение методов = изменение поведения метода в подклассе
         */
        
        BankAccount account1 = new BankAccount(10000);
        BankAccount account2 = new SavingsAccount(10000);
        BankAccount account3 = new PremiumAccount(10000);

        System.out.println(account1.getAccountType() + " → Процент: " + account1.calculateInterest() + " руб.");
        System.out.println(account2.getAccountType() + " → Процент: " + account2.calculateInterest() + " руб.");
        System.out.println(account3.getAccountType() + " → Процент: " + account3.calculateInterest() + " руб.");
        
        /* ПРАВИЛА ПЕРЕОПРЕДЕЛЕНИЯ:
         * 1. Метод должен иметь ТО ЖЕ ИМЯ
         * 2. Метод должен иметь ТЕ ЖЕ ПАРАМЕТРЫ (сигнатура)
         * 3. Возвращаемый тип должен быть ТЕМ ЖЕ или подтипом
         * 4. Модификатор доступа должен быть ТАКИМ ЖЕ или более открытым
         * 5. Нельзя переопределить private, static, final методы
         */
        
        /* АННОТАЦИЯ @Override:
         * ✓ Не обязательна, но НАСТОЯТЕЛЬНО РЕКОМЕНДУЕТСЯ
         * ✓ Помогает компилятору проверить корректность переопределения
         * ✓ Предотвращает ошибки (опечатки в имени метода)
         */

        /* ========================================
         * БЛОК 4: FINAL КЛАССЫ И МЕТОДЫ
         * ========================================
         * final используется для:
         * - Запрета наследования (final class)
         * - Запрета переопределения (final method)
         * - Неизменяемых полей (final field)
         */
        
        /* 1. final КЛАСС — нельзя наследовать
         *    Примеры: String, Integer, Double, Math
         */
        
        /* 2. final МЕТОД — нельзя переопределить
         *    Используется, когда переопределение может нарушить логику
         */
        
        /* 3. final ПОЛЕ — нельзя изменить после инициализации
         *    Используется для immutable объектов и констант
         */
        
        Payment payment = new Payment(1L, 1000.0);
        System.out.println("Платёж: id=" + payment.getId() + ", amount=" + payment.getAmount());
        // id и amount нельзя изменить после создания объекта (final поля)

        /* ========================================
         * ИТОГИ
         * ========================================
         * 1. НАСЛЕДОВАНИЕ = переиспользование кода через extends
         * 2. Отношение IS-A: Client IS-A Person
         * 3. super() вызывает конструктор суперкласса (первая строка!)
         * 4. @Override переопределяет метод суперкласса
         * 5. final class — запрет наследования
         * 6. final method — запрет переопределения
         * 7. final field — неизменяемое поле
         */
    }
}
